{"version":3,"file":"/Users/marco/z_not_sync/coding/personal_site/assets/js/lib/chess-1.2.0.min.js.map","sources":["/Users/marco/z_not_sync/coding/personal_site/dev/js/lib/chess-1.2.0.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Chess = exports.validateFen = exports.SEVEN_TAG_ROSTER = exports.SQUARES = exports.Move = exports.DEFAULT_POSITION = exports.KING = exports.QUEEN = exports.ROOK = exports.BISHOP = exports.KNIGHT = exports.PAWN = exports.BLACK = exports.WHITE = void 0;\nexports.WHITE = 'w';\nexports.BLACK = 'b';\nexports.PAWN = 'p';\nexports.KNIGHT = 'n';\nexports.BISHOP = 'b';\nexports.ROOK = 'r';\nexports.QUEEN = 'q';\nexports.KING = 'k';\nexports.DEFAULT_POSITION = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';\nclass Move {\n    color;\n    from;\n    to;\n    piece;\n    captured;\n    promotion;\n    /**\n     * @deprecated This field is deprecated and will be removed in version 2.0.0.\n     * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n     * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n     * `isBigPawn`\n     */\n    flags;\n    san;\n    lan;\n    before;\n    after;\n    constructor(chess, internal) {\n        const { color, piece, from, to, flags, captured, promotion } = internal;\n        const fromAlgebraic = algebraic(from);\n        const toAlgebraic = algebraic(to);\n        this.color = color;\n        this.piece = piece;\n        this.from = fromAlgebraic;\n        this.to = toAlgebraic;\n        /*\n         * HACK: The chess['_method']() calls below invoke private methods in the\n         * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n         * code cleaner elsewhere.\n         */\n        this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }));\n        this.lan = fromAlgebraic + toAlgebraic;\n        this.before = chess.fen();\n        // Generate the FEN for the 'after' key\n        chess['_makeMove'](internal);\n        this.after = chess.fen();\n        chess['_undoMove']();\n        // Build the text representation of the move flags\n        this.flags = '';\n        for (const flag in BITS) {\n            if (BITS[flag] & flags) {\n                this.flags += FLAGS[flag];\n            }\n        }\n        if (captured) {\n            this.captured = captured;\n        }\n        if (promotion) {\n            this.promotion = promotion;\n            this.lan += promotion;\n        }\n    }\n    isCapture() {\n        return this.flags.indexOf(FLAGS['CAPTURE']) > -1;\n    }\n    isPromotion() {\n        return this.flags.indexOf(FLAGS['PROMOTION']) > -1;\n    }\n    isEnPassant() {\n        return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1;\n    }\n    isKingsideCastle() {\n        return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1;\n    }\n    isQueensideCastle() {\n        return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1;\n    }\n    isBigPawn() {\n        return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1;\n    }\n}\nexports.Move = Move;\nconst EMPTY = -1;\nconst FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n};\n// prettier-ignore\nexports.SQUARES = [\n    'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n    'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n    'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n    'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n    'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n    'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n    'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n    'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n];\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n};\n/* eslint-disable @typescript-eslint/naming-convention */\n// these are required, according to spec\nexports.SEVEN_TAG_ROSTER = {\n    Event: '?',\n    Site: '?',\n    Date: '????.??.??',\n    Round: '?',\n    White: '?',\n    Black: '?',\n    Result: '*',\n};\n/**\n * These nulls are placeholders to fix the order of tags (as they appear in PGN spec); null values will be\n * eliminated in getHeaders()\n */\nconst SUPLEMENTAL_TAGS = {\n    WhiteTitle: null,\n    BlackTitle: null,\n    WhiteElo: null,\n    BlackElo: null,\n    WhiteUSCF: null,\n    BlackUSCF: null,\n    WhiteNA: null,\n    BlackNA: null,\n    WhiteType: null,\n    BlackType: null,\n    EventDate: null,\n    EventSponsor: null,\n    Section: null,\n    Stage: null,\n    Board: null,\n    Opening: null,\n    Variation: null,\n    SubVariation: null,\n    ECO: null,\n    NIC: null,\n    Time: null,\n    UTCTime: null,\n    UTCDate: null,\n    TimeControl: null,\n    SetUp: null,\n    FEN: null,\n    Termination: null,\n    Annotator: null,\n    Mode: null,\n    PlyCount: null,\n};\nconst HEADER_TEMPLATE = {\n    ...exports.SEVEN_TAG_ROSTER,\n    ...SUPLEMENTAL_TAGS,\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88 = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n};\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n};\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n};\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n];\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n];\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 };\nconst SYMBOLS = 'pnbrqkPNBRQK';\nconst PROMOTIONS = [exports.KNIGHT, exports.BISHOP, exports.ROOK, exports.QUEEN];\nconst RANK_1 = 7;\nconst RANK_2 = 6;\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1;\nconst RANK_8 = 0;\nconst SIDES = {\n    [exports.KING]: BITS.KSIDE_CASTLE,\n    [exports.QUEEN]: BITS.QSIDE_CASTLE,\n};\nconst ROOKS = {\n    w: [\n        { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n    ],\n    b: [\n        { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n        { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n    ],\n};\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 };\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*'];\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square) {\n    return square >> 4;\n}\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square) {\n    return square & 0xf;\n}\nfunction isDigit(c) {\n    return '0123456789'.indexOf(c) !== -1;\n}\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square) {\n    const f = file(square);\n    const r = rank(square);\n    return ('abcdefgh'.substring(f, f + 1) +\n        '87654321'.substring(r, r + 1));\n}\nfunction swapColor(color) {\n    return color === exports.WHITE ? exports.BLACK : exports.WHITE;\n}\nfunction validateFen(fen) {\n    // 1st criterion: 6 space-seperated fields?\n    const tokens = fen.split(/\\s+/);\n    if (tokens.length !== 6) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: must contain six space-delimited fields',\n        };\n    }\n    // 2nd criterion: move number field is a integer value > 0?\n    const moveNumber = parseInt(tokens[5], 10);\n    if (isNaN(moveNumber) || moveNumber <= 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: move number must be a positive integer',\n        };\n    }\n    // 3rd criterion: half move counter is an integer >= 0?\n    const halfMoves = parseInt(tokens[4], 10);\n    if (isNaN(halfMoves) || halfMoves < 0) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: half move counter number must be a non-negative integer',\n        };\n    }\n    // 4th criterion: 4th field is a valid e.p.-string?\n    if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n        return { ok: false, error: 'Invalid FEN: en-passant square is invalid' };\n    }\n    // 5th criterion: 3th field is a valid castle-string?\n    if (/[^kKqQ-]/.test(tokens[2])) {\n        return { ok: false, error: 'Invalid FEN: castling availability is invalid' };\n    }\n    // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n    if (!/^(w|b)$/.test(tokens[1])) {\n        return { ok: false, error: 'Invalid FEN: side-to-move is invalid' };\n    }\n    // 7th criterion: 1st field contains 8 rows?\n    const rows = tokens[0].split('/');\n    if (rows.length !== 8) {\n        return {\n            ok: false,\n            error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n        };\n    }\n    // 8th criterion: every row is valid?\n    for (let i = 0; i < rows.length; i++) {\n        // check for right sum of fields AND not two numbers in succession\n        let sumFields = 0;\n        let previousWasNumber = false;\n        for (let k = 0; k < rows[i].length; k++) {\n            if (isDigit(rows[i][k])) {\n                if (previousWasNumber) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (consecutive number)',\n                    };\n                }\n                sumFields += parseInt(rows[i][k], 10);\n                previousWasNumber = true;\n            }\n            else {\n                if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                    return {\n                        ok: false,\n                        error: 'Invalid FEN: piece data is invalid (invalid piece)',\n                    };\n                }\n                sumFields += 1;\n                previousWasNumber = false;\n            }\n        }\n        if (sumFields !== 8) {\n            return {\n                ok: false,\n                error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n            };\n        }\n    }\n    // 9th criterion: is en-passant square legal?\n    if ((tokens[3][1] == '3' && tokens[1] == 'w') ||\n        (tokens[3][1] == '6' && tokens[1] == 'b')) {\n        return { ok: false, error: 'Invalid FEN: illegal en-passant square' };\n    }\n    // 10th criterion: does chess position contain exact two kings?\n    const kings = [\n        { color: 'white', regex: /K/g },\n        { color: 'black', regex: /k/g },\n    ];\n    for (const { color, regex } of kings) {\n        if (!regex.test(tokens[0])) {\n            return { ok: false, error: `Invalid FEN: missing ${color} king` };\n        }\n        if ((tokens[0].match(regex) || []).length > 1) {\n            return { ok: false, error: `Invalid FEN: too many ${color} kings` };\n        }\n    }\n    // 11th criterion: are any pawns on the first or eighth rows?\n    if (Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')) {\n        return {\n            ok: false,\n            error: 'Invalid FEN: some pawns are on the edge rows',\n        };\n    }\n    return { ok: true };\n}\nexports.validateFen = validateFen;\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move, moves) {\n    const from = move.from;\n    const to = move.to;\n    const piece = move.piece;\n    let ambiguities = 0;\n    let sameRank = 0;\n    let sameFile = 0;\n    for (let i = 0, len = moves.length; i < len; i++) {\n        const ambigFrom = moves[i].from;\n        const ambigTo = moves[i].to;\n        const ambigPiece = moves[i].piece;\n        /*\n         * if a move of the same piece type ends on the same to square, we'll need\n         * to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n            ambiguities++;\n            if (rank(from) === rank(ambigFrom)) {\n                sameRank++;\n            }\n            if (file(from) === file(ambigFrom)) {\n                sameFile++;\n            }\n        }\n    }\n    if (ambiguities > 0) {\n        if (sameRank > 0 && sameFile > 0) {\n            /*\n             * if there exists a similar moving piece on the same rank and file as\n             * the move in question, use the square as the disambiguator\n             */\n            return algebraic(from);\n        }\n        else if (sameFile > 0) {\n            /*\n             * if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1);\n        }\n        else {\n            // else use the file symbol\n            return algebraic(from).charAt(0);\n        }\n    }\n    return '';\n}\nfunction addMove(moves, color, from, to, piece, captured = undefined, flags = BITS.NORMAL) {\n    const r = rank(to);\n    if (piece === exports.PAWN && (r === RANK_1 || r === RANK_8)) {\n        for (let i = 0; i < PROMOTIONS.length; i++) {\n            const promotion = PROMOTIONS[i];\n            moves.push({\n                color,\n                from,\n                to,\n                piece,\n                captured,\n                promotion,\n                flags: flags | BITS.PROMOTION,\n            });\n        }\n    }\n    else {\n        moves.push({\n            color,\n            from,\n            to,\n            piece,\n            captured,\n            flags,\n        });\n    }\n}\nfunction inferPieceType(san) {\n    let pieceType = san.charAt(0);\n    if (pieceType >= 'a' && pieceType <= 'h') {\n        const matches = san.match(/[a-h]\\d.*[a-h]\\d/);\n        if (matches) {\n            return undefined;\n        }\n        return exports.PAWN;\n    }\n    pieceType = pieceType.toLowerCase();\n    if (pieceType === 'o') {\n        return exports.KING;\n    }\n    return pieceType;\n}\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '');\n}\nfunction trimFen(fen) {\n    /*\n     * remove last two fields in FEN string as they're not needed when checking\n     * for repetition\n     */\n    return fen.split(' ').slice(0, 4).join(' ');\n}\nclass Chess {\n    _board = new Array(128);\n    _turn = exports.WHITE;\n    _header = {};\n    _kings = { w: EMPTY, b: EMPTY };\n    _epSquare = -1;\n    _halfMoves = 0;\n    _moveNumber = 0;\n    _history = [];\n    _comments = {};\n    _castling = { w: 0, b: 0 };\n    // tracks number of times a position has been seen for repetition checking\n    _positionCount = {};\n    constructor(fen = exports.DEFAULT_POSITION, { skipValidation = false } = {}) {\n        this.load(fen, { skipValidation });\n    }\n    clear({ preserveHeaders = false } = {}) {\n        this._board = new Array(128);\n        this._kings = { w: EMPTY, b: EMPTY };\n        this._turn = exports.WHITE;\n        this._castling = { w: 0, b: 0 };\n        this._epSquare = EMPTY;\n        this._halfMoves = 0;\n        this._moveNumber = 1;\n        this._history = [];\n        this._comments = {};\n        this._header = preserveHeaders ? this._header : { ...HEADER_TEMPLATE };\n        this._positionCount = {};\n        /*\n         * Delete the SetUp and FEN headers (if preserved), the board is empty and\n         * these headers don't make sense in this state. They'll get added later\n         * via .load() or .put()\n         */\n        this._header['SetUp'] = null;\n        this._header['FEN'] = null;\n    }\n    load(fen, { skipValidation = false, preserveHeaders = false } = {}) {\n        let tokens = fen.split(/\\s+/);\n        // append commonly omitted fen tokens\n        if (tokens.length >= 2 && tokens.length < 6) {\n            const adjustments = ['-', '-', '0', '1'];\n            fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ');\n        }\n        tokens = fen.split(/\\s+/);\n        if (!skipValidation) {\n            const { ok, error } = validateFen(fen);\n            if (!ok) {\n                throw new Error(error);\n            }\n        }\n        const position = tokens[0];\n        let square = 0;\n        this.clear({ preserveHeaders });\n        for (let i = 0; i < position.length; i++) {\n            const piece = position.charAt(i);\n            if (piece === '/') {\n                square += 8;\n            }\n            else if (isDigit(piece)) {\n                square += parseInt(piece, 10);\n            }\n            else {\n                const color = piece < 'a' ? exports.WHITE : exports.BLACK;\n                this._put({ type: piece.toLowerCase(), color }, algebraic(square));\n                square++;\n            }\n        }\n        this._turn = tokens[1];\n        if (tokens[2].indexOf('K') > -1) {\n            this._castling.w |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            this._castling.w |= BITS.QSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            this._castling.b |= BITS.KSIDE_CASTLE;\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            this._castling.b |= BITS.QSIDE_CASTLE;\n        }\n        this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3]];\n        this._halfMoves = parseInt(tokens[4], 10);\n        this._moveNumber = parseInt(tokens[5], 10);\n        this._updateSetup(fen);\n        this._incPositionCount(fen);\n    }\n    fen() {\n        let empty = 0;\n        let fen = '';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i]) {\n                if (empty > 0) {\n                    fen += empty;\n                    empty = 0;\n                }\n                const { color, type: piece } = this._board[i];\n                fen += color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n            }\n            else {\n                empty++;\n            }\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty;\n                }\n                if (i !== Ox88.h1) {\n                    fen += '/';\n                }\n                empty = 0;\n                i += 8;\n            }\n        }\n        let castling = '';\n        if (this._castling[exports.WHITE] & BITS.KSIDE_CASTLE) {\n            castling += 'K';\n        }\n        if (this._castling[exports.WHITE] & BITS.QSIDE_CASTLE) {\n            castling += 'Q';\n        }\n        if (this._castling[exports.BLACK] & BITS.KSIDE_CASTLE) {\n            castling += 'k';\n        }\n        if (this._castling[exports.BLACK] & BITS.QSIDE_CASTLE) {\n            castling += 'q';\n        }\n        // do we have an empty castling flag?\n        castling = castling || '-';\n        let epSquare = '-';\n        /*\n         * only print the ep square if en passant is a valid move (pawn is present\n         * and ep capture is not pinned)\n         */\n        if (this._epSquare !== EMPTY) {\n            const bigPawnSquare = this._epSquare + (this._turn === exports.WHITE ? 16 : -16);\n            const squares = [bigPawnSquare + 1, bigPawnSquare - 1];\n            for (const square of squares) {\n                // is the square off the board?\n                if (square & 0x88) {\n                    continue;\n                }\n                const color = this._turn;\n                // is there a pawn that can capture the epSquare?\n                if (this._board[square]?.color === color &&\n                    this._board[square]?.type === exports.PAWN) {\n                    // if the pawn makes an ep capture, does it leave it's king in check?\n                    this._makeMove({\n                        color,\n                        from: square,\n                        to: this._epSquare,\n                        piece: exports.PAWN,\n                        captured: exports.PAWN,\n                        flags: BITS.EP_CAPTURE,\n                    });\n                    const isLegal = !this._isKingAttacked(color);\n                    this._undoMove();\n                    // if ep is legal, break and set the ep square in the FEN output\n                    if (isLegal) {\n                        epSquare = algebraic(this._epSquare);\n                        break;\n                    }\n                }\n            }\n        }\n        return [\n            fen,\n            this._turn,\n            castling,\n            epSquare,\n            this._halfMoves,\n            this._moveNumber,\n        ].join(' ');\n    }\n    /*\n     * Called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object. If the FEN\n     * is equal to the default position, the SetUp and FEN are deleted the setup\n     * is only updated if history.length is zero, ie moves haven't been made.\n     */\n    _updateSetup(fen) {\n        if (this._history.length > 0)\n            return;\n        if (fen !== exports.DEFAULT_POSITION) {\n            this._header['SetUp'] = '1';\n            this._header['FEN'] = fen;\n        }\n        else {\n            this._header['SetUp'] = null;\n            this._header['FEN'] = null;\n        }\n    }\n    reset() {\n        this.load(exports.DEFAULT_POSITION);\n    }\n    get(square) {\n        return this._board[Ox88[square]];\n    }\n    findPiece(piece) {\n        const squares = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (!this._board[i] || this._board[i]?.color !== piece.color) {\n                continue;\n            }\n            // check if square contains the requested piece\n            if (this._board[i].color === piece.color &&\n                this._board[i].type === piece.type) {\n                squares.push(algebraic(i));\n            }\n        }\n        return squares;\n    }\n    put({ type, color }, square) {\n        if (this._put({ type, color }, square)) {\n            this._updateCastlingRights();\n            this._updateEnPassantSquare();\n            this._updateSetup(this.fen());\n            return true;\n        }\n        return false;\n    }\n    _put({ type, color }, square) {\n        // check for piece\n        if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n            return false;\n        }\n        // check for valid square\n        if (!(square in Ox88)) {\n            return false;\n        }\n        const sq = Ox88[square];\n        // don't let the user place more than one king\n        if (type == exports.KING &&\n            !(this._kings[color] == EMPTY || this._kings[color] == sq)) {\n            return false;\n        }\n        const currentPieceOnSquare = this._board[sq];\n        // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n        if (currentPieceOnSquare && currentPieceOnSquare.type === exports.KING) {\n            this._kings[currentPieceOnSquare.color] = EMPTY;\n        }\n        this._board[sq] = { type: type, color: color };\n        if (type === exports.KING) {\n            this._kings[color] = sq;\n        }\n        return true;\n    }\n    remove(square) {\n        const piece = this.get(square);\n        delete this._board[Ox88[square]];\n        if (piece && piece.type === exports.KING) {\n            this._kings[piece.color] = EMPTY;\n        }\n        this._updateCastlingRights();\n        this._updateEnPassantSquare();\n        this._updateSetup(this.fen());\n        return piece;\n    }\n    _updateCastlingRights() {\n        const whiteKingInPlace = this._board[Ox88.e1]?.type === exports.KING &&\n            this._board[Ox88.e1]?.color === exports.WHITE;\n        const blackKingInPlace = this._board[Ox88.e8]?.type === exports.KING &&\n            this._board[Ox88.e8]?.color === exports.BLACK;\n        if (!whiteKingInPlace ||\n            this._board[Ox88.a1]?.type !== exports.ROOK ||\n            this._board[Ox88.a1]?.color !== exports.WHITE) {\n            this._castling.w &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!whiteKingInPlace ||\n            this._board[Ox88.h1]?.type !== exports.ROOK ||\n            this._board[Ox88.h1]?.color !== exports.WHITE) {\n            this._castling.w &= ~BITS.KSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.a8]?.type !== exports.ROOK ||\n            this._board[Ox88.a8]?.color !== exports.BLACK) {\n            this._castling.b &= ~BITS.QSIDE_CASTLE;\n        }\n        if (!blackKingInPlace ||\n            this._board[Ox88.h8]?.type !== exports.ROOK ||\n            this._board[Ox88.h8]?.color !== exports.BLACK) {\n            this._castling.b &= ~BITS.KSIDE_CASTLE;\n        }\n    }\n    _updateEnPassantSquare() {\n        if (this._epSquare === EMPTY) {\n            return;\n        }\n        const startSquare = this._epSquare + (this._turn === exports.WHITE ? -16 : 16);\n        const currentSquare = this._epSquare + (this._turn === exports.WHITE ? 16 : -16);\n        const attackers = [currentSquare + 1, currentSquare - 1];\n        if (this._board[startSquare] !== null ||\n            this._board[this._epSquare] !== null ||\n            this._board[currentSquare]?.color !== swapColor(this._turn) ||\n            this._board[currentSquare]?.type !== exports.PAWN) {\n            this._epSquare = EMPTY;\n            return;\n        }\n        const canCapture = (square) => !(square & 0x88) &&\n            this._board[square]?.color === this._turn &&\n            this._board[square]?.type === exports.PAWN;\n        if (!attackers.some(canCapture)) {\n            this._epSquare = EMPTY;\n        }\n    }\n    _attacked(color, square, verbose) {\n        const attackers = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // did we run off the end of the board\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            // if empty square or wrong color\n            if (this._board[i] === undefined || this._board[i].color !== color) {\n                continue;\n            }\n            const piece = this._board[i];\n            const difference = i - square;\n            // skip - to/from square are the same\n            if (difference === 0) {\n                continue;\n            }\n            const index = difference + 119;\n            if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n                if (piece.type === exports.PAWN) {\n                    if ((difference > 0 && piece.color === exports.WHITE) ||\n                        (difference <= 0 && piece.color === exports.BLACK)) {\n                        if (!verbose) {\n                            return true;\n                        }\n                        else {\n                            attackers.push(algebraic(i));\n                        }\n                    }\n                    continue;\n                }\n                // if the piece is a knight or a king\n                if (piece.type === 'n' || piece.type === 'k') {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n                const offset = RAYS[index];\n                let j = i + offset;\n                let blocked = false;\n                while (j !== square) {\n                    if (this._board[j] != null) {\n                        blocked = true;\n                        break;\n                    }\n                    j += offset;\n                }\n                if (!blocked) {\n                    if (!verbose) {\n                        return true;\n                    }\n                    else {\n                        attackers.push(algebraic(i));\n                        continue;\n                    }\n                }\n            }\n        }\n        if (verbose) {\n            return attackers;\n        }\n        else {\n            return false;\n        }\n    }\n    attackers(square, attackedBy) {\n        if (!attackedBy) {\n            return this._attacked(this._turn, Ox88[square], true);\n        }\n        else {\n            return this._attacked(attackedBy, Ox88[square], true);\n        }\n    }\n    _isKingAttacked(color) {\n        const square = this._kings[color];\n        return square === -1 ? false : this._attacked(swapColor(color), square);\n    }\n    isAttacked(square, attackedBy) {\n        return this._attacked(attackedBy, Ox88[square]);\n    }\n    isCheck() {\n        return this._isKingAttacked(this._turn);\n    }\n    inCheck() {\n        return this.isCheck();\n    }\n    isCheckmate() {\n        return this.isCheck() && this._moves().length === 0;\n    }\n    isStalemate() {\n        return !this.isCheck() && this._moves().length === 0;\n    }\n    isInsufficientMaterial() {\n        /*\n         * k.b. vs k.b. (of opposite colors) with mate in 1:\n         * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n         *\n         * k.b. vs k.n. with mate in 1:\n         * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n         */\n        const pieces = {\n            b: 0,\n            n: 0,\n            r: 0,\n            q: 0,\n            k: 0,\n            p: 0,\n        };\n        const bishops = [];\n        let numPieces = 0;\n        let squareColor = 0;\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            squareColor = (squareColor + 1) % 2;\n            if (i & 0x88) {\n                i += 7;\n                continue;\n            }\n            const piece = this._board[i];\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1;\n                if (piece.type === exports.BISHOP) {\n                    bishops.push(squareColor);\n                }\n                numPieces++;\n            }\n        }\n        // k vs. k\n        if (numPieces === 2) {\n            return true;\n        }\n        else if (\n        // k vs. kn .... or .... k vs. kb\n        numPieces === 3 &&\n            (pieces[exports.BISHOP] === 1 || pieces[exports.KNIGHT] === 1)) {\n            return true;\n        }\n        else if (numPieces === pieces[exports.BISHOP] + 2) {\n            // kb vs. kb where any number of bishops are all on the same color\n            let sum = 0;\n            const len = bishops.length;\n            for (let i = 0; i < len; i++) {\n                sum += bishops[i];\n            }\n            if (sum === 0 || sum === len) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isThreefoldRepetition() {\n        return this._getPositionCount(this.fen()) >= 3;\n    }\n    isDrawByFiftyMoves() {\n        return this._halfMoves >= 100; // 50 moves per side = 100 half moves\n    }\n    isDraw() {\n        return (this.isDrawByFiftyMoves() ||\n            this.isStalemate() ||\n            this.isInsufficientMaterial() ||\n            this.isThreefoldRepetition());\n    }\n    isGameOver() {\n        return this.isCheckmate() || this.isStalemate() || this.isDraw();\n    }\n    moves({ verbose = false, square = undefined, piece = undefined, } = {}) {\n        const moves = this._moves({ square, piece });\n        if (verbose) {\n            return moves.map((move) => new Move(this, move));\n        }\n        else {\n            return moves.map((move) => this._moveToSan(move, moves));\n        }\n    }\n    _moves({ legal = true, piece = undefined, square = undefined, } = {}) {\n        const forSquare = square ? square.toLowerCase() : undefined;\n        const forPiece = piece?.toLowerCase();\n        const moves = [];\n        const us = this._turn;\n        const them = swapColor(us);\n        let firstSquare = Ox88.a8;\n        let lastSquare = Ox88.h1;\n        let singleSquare = false;\n        // are we generating moves for a single square?\n        if (forSquare) {\n            // illegal square, return empty moves\n            if (!(forSquare in Ox88)) {\n                return [];\n            }\n            else {\n                firstSquare = lastSquare = Ox88[forSquare];\n                singleSquare = true;\n            }\n        }\n        for (let from = firstSquare; from <= lastSquare; from++) {\n            // did we run off the end of the board\n            if (from & 0x88) {\n                from += 7;\n                continue;\n            }\n            // empty square or opponent, skip\n            if (!this._board[from] || this._board[from].color === them) {\n                continue;\n            }\n            const { type } = this._board[from];\n            let to;\n            if (type === exports.PAWN) {\n                if (forPiece && forPiece !== type)\n                    continue;\n                // single square, non-capturing\n                to = from + PAWN_OFFSETS[us][0];\n                if (!this._board[to]) {\n                    addMove(moves, us, from, to, exports.PAWN);\n                    // double square\n                    to = from + PAWN_OFFSETS[us][1];\n                    if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n                        addMove(moves, us, from, to, exports.PAWN, undefined, BITS.BIG_PAWN);\n                    }\n                }\n                // pawn captures\n                for (let j = 2; j < 4; j++) {\n                    to = from + PAWN_OFFSETS[us][j];\n                    if (to & 0x88)\n                        continue;\n                    if (this._board[to]?.color === them) {\n                        addMove(moves, us, from, to, exports.PAWN, this._board[to].type, BITS.CAPTURE);\n                    }\n                    else if (to === this._epSquare) {\n                        addMove(moves, us, from, to, exports.PAWN, exports.PAWN, BITS.EP_CAPTURE);\n                    }\n                }\n            }\n            else {\n                if (forPiece && forPiece !== type)\n                    continue;\n                for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n                    const offset = PIECE_OFFSETS[type][j];\n                    to = from;\n                    while (true) {\n                        to += offset;\n                        if (to & 0x88)\n                            break;\n                        if (!this._board[to]) {\n                            addMove(moves, us, from, to, type);\n                        }\n                        else {\n                            // own color, stop loop\n                            if (this._board[to].color === us)\n                                break;\n                            addMove(moves, us, from, to, type, this._board[to].type, BITS.CAPTURE);\n                            break;\n                        }\n                        /* break, if knight or king */\n                        if (type === exports.KNIGHT || type === exports.KING)\n                            break;\n                    }\n                }\n            }\n        }\n        /*\n         * check for castling if we're:\n         *   a) generating all moves, or\n         *   b) doing single square move generation on the king's square\n         */\n        if (forPiece === undefined || forPiece === exports.KING) {\n            if (!singleSquare || lastSquare === this._kings[us]) {\n                // king-side castling\n                if (this._castling[us] & BITS.KSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom + 2;\n                    if (!this._board[castlingFrom + 1] &&\n                        !this._board[castlingTo] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom + 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.KSIDE_CASTLE);\n                    }\n                }\n                // queen-side castling\n                if (this._castling[us] & BITS.QSIDE_CASTLE) {\n                    const castlingFrom = this._kings[us];\n                    const castlingTo = castlingFrom - 2;\n                    if (!this._board[castlingFrom - 1] &&\n                        !this._board[castlingFrom - 2] &&\n                        !this._board[castlingFrom - 3] &&\n                        !this._attacked(them, this._kings[us]) &&\n                        !this._attacked(them, castlingFrom - 1) &&\n                        !this._attacked(them, castlingTo)) {\n                        addMove(moves, us, this._kings[us], castlingTo, exports.KING, undefined, BITS.QSIDE_CASTLE);\n                    }\n                }\n            }\n        }\n        /*\n         * return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal || this._kings[us] === -1) {\n            return moves;\n        }\n        // filter out illegal moves\n        const legalMoves = [];\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(us)) {\n                legalMoves.push(moves[i]);\n            }\n            this._undoMove();\n        }\n        return legalMoves;\n    }\n    move(move, { strict = false } = {}) {\n        /*\n         * The move function can be called with in the following parameters:\n         *\n         * .move('Nxb7')       <- argument is a case-sensitive SAN string\n         *\n         * .move({ from: 'h7', <- argument is a move object\n         *         to :'h8',\n         *         promotion: 'q' })\n         *\n         *\n         * An optional strict argument may be supplied to tell chess.js to\n         * strictly follow the SAN specification.\n         */\n        let moveObj = null;\n        if (typeof move === 'string') {\n            moveObj = this._moveFromSan(move, strict);\n        }\n        else if (typeof move === 'object') {\n            const moves = this._moves();\n            // convert the pretty move object to an ugly move object\n            for (let i = 0, len = moves.length; i < len; i++) {\n                if (move.from === algebraic(moves[i].from) &&\n                    move.to === algebraic(moves[i].to) &&\n                    (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)) {\n                    moveObj = moves[i];\n                    break;\n                }\n            }\n        }\n        // failed to find move\n        if (!moveObj) {\n            if (typeof move === 'string') {\n                throw new Error(`Invalid move: ${move}`);\n            }\n            else {\n                throw new Error(`Invalid move: ${JSON.stringify(move)}`);\n            }\n        }\n        /*\n         * need to make a copy of move because we can't generate SAN after the move\n         * is made\n         */\n        const prettyMove = new Move(this, moveObj);\n        this._makeMove(moveObj);\n        this._incPositionCount(prettyMove.after);\n        return prettyMove;\n    }\n    _push(move) {\n        this._history.push({\n            move,\n            kings: { b: this._kings.b, w: this._kings.w },\n            turn: this._turn,\n            castling: { b: this._castling.b, w: this._castling.w },\n            epSquare: this._epSquare,\n            halfMoves: this._halfMoves,\n            moveNumber: this._moveNumber,\n        });\n    }\n    _makeMove(move) {\n        const us = this._turn;\n        const them = swapColor(us);\n        this._push(move);\n        this._board[move.to] = this._board[move.from];\n        delete this._board[move.from];\n        // if ep capture, remove the captured pawn\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (this._turn === exports.BLACK) {\n                delete this._board[move.to - 16];\n            }\n            else {\n                delete this._board[move.to + 16];\n            }\n        }\n        // if pawn promotion, replace with new piece\n        if (move.promotion) {\n            this._board[move.to] = { type: move.promotion, color: us };\n        }\n        // if we moved the king\n        if (this._board[move.to].type === exports.KING) {\n            this._kings[us] = move.to;\n            // if we castled, move the rook next to the king\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                const castlingTo = move.to - 1;\n                const castlingFrom = move.to + 1;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            else if (move.flags & BITS.QSIDE_CASTLE) {\n                const castlingTo = move.to + 1;\n                const castlingFrom = move.to - 2;\n                this._board[castlingTo] = this._board[castlingFrom];\n                delete this._board[castlingFrom];\n            }\n            // turn off castling\n            this._castling[us] = 0;\n        }\n        // turn off castling if we move a rook\n        if (this._castling[us]) {\n            for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (move.from === ROOKS[us][i].square &&\n                    this._castling[us] & ROOKS[us][i].flag) {\n                    this._castling[us] ^= ROOKS[us][i].flag;\n                    break;\n                }\n            }\n        }\n        // turn off castling if we capture a rook\n        if (this._castling[them]) {\n            for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (move.to === ROOKS[them][i].square &&\n                    this._castling[them] & ROOKS[them][i].flag) {\n                    this._castling[them] ^= ROOKS[them][i].flag;\n                    break;\n                }\n            }\n        }\n        // if big pawn move, update the en passant square\n        if (move.flags & BITS.BIG_PAWN) {\n            if (us === exports.BLACK) {\n                this._epSquare = move.to - 16;\n            }\n            else {\n                this._epSquare = move.to + 16;\n            }\n        }\n        else {\n            this._epSquare = EMPTY;\n        }\n        // reset the 50 move counter if a pawn is moved or a piece is captured\n        if (move.piece === exports.PAWN) {\n            this._halfMoves = 0;\n        }\n        else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            this._halfMoves = 0;\n        }\n        else {\n            this._halfMoves++;\n        }\n        if (us === exports.BLACK) {\n            this._moveNumber++;\n        }\n        this._turn = them;\n    }\n    undo() {\n        const move = this._undoMove();\n        if (move) {\n            const prettyMove = new Move(this, move);\n            this._decPositionCount(prettyMove.after);\n            return prettyMove;\n        }\n        return null;\n    }\n    _undoMove() {\n        const old = this._history.pop();\n        if (old === undefined) {\n            return null;\n        }\n        const move = old.move;\n        this._kings = old.kings;\n        this._turn = old.turn;\n        this._castling = old.castling;\n        this._epSquare = old.epSquare;\n        this._halfMoves = old.halfMoves;\n        this._moveNumber = old.moveNumber;\n        const us = this._turn;\n        const them = swapColor(us);\n        this._board[move.from] = this._board[move.to];\n        this._board[move.from].type = move.piece; // to undo any promotions\n        delete this._board[move.to];\n        if (move.captured) {\n            if (move.flags & BITS.EP_CAPTURE) {\n                // en passant capture\n                let index;\n                if (us === exports.BLACK) {\n                    index = move.to - 16;\n                }\n                else {\n                    index = move.to + 16;\n                }\n                this._board[index] = { type: exports.PAWN, color: them };\n            }\n            else {\n                // regular capture\n                this._board[move.to] = { type: move.captured, color: them };\n            }\n        }\n        if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            let castlingTo, castlingFrom;\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castlingTo = move.to + 1;\n                castlingFrom = move.to - 1;\n            }\n            else {\n                castlingTo = move.to - 2;\n                castlingFrom = move.to + 1;\n            }\n            this._board[castlingTo] = this._board[castlingFrom];\n            delete this._board[castlingFrom];\n        }\n        return move;\n    }\n    pgn({ newline = '\\n', maxWidth = 0, } = {}) {\n        /*\n         * using the specification from http://www.chessclub.com/help/PGN-spec\n         * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n         */\n        const result = [];\n        let headerExists = false;\n        /* add the PGN header information */\n        for (const i in this._header) {\n            /*\n             * TODO: order of enumerated properties in header object is not\n             * guaranteed, see ECMA-262 spec (section 12.6.4)\n             *\n             * By using HEADER_TEMPLATE, the order of tags should be preserved; we\n             * do have to check for null placeholders, though, and omit them\n             */\n            const headerTag = this._header[i];\n            if (headerTag)\n                result.push(`[${i} \"${this._header[i]}\"]` + newline);\n            headerExists = true;\n        }\n        if (headerExists && this._history.length) {\n            result.push(newline);\n        }\n        const appendComment = (moveString) => {\n            const comment = this._comments[this.fen()];\n            if (typeof comment !== 'undefined') {\n                const delimiter = moveString.length > 0 ? ' ' : '';\n                moveString = `${moveString}${delimiter}{${comment}}`;\n            }\n            return moveString;\n        };\n        // pop all of history onto reversed_history\n        const reversedHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        const moves = [];\n        let moveString = '';\n        // special case of a commented starting position with no moves\n        if (reversedHistory.length === 0) {\n            moves.push(appendComment(''));\n        }\n        // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n        while (reversedHistory.length > 0) {\n            moveString = appendComment(moveString);\n            const move = reversedHistory.pop();\n            // make TypeScript stop complaining about move being undefined\n            if (!move) {\n                break;\n            }\n            // if the position started with black to move, start PGN with #. ...\n            if (!this._history.length && move.color === 'b') {\n                const prefix = `${this._moveNumber}. ...`;\n                // is there a comment preceding the first move?\n                moveString = moveString ? `${moveString} ${prefix}` : prefix;\n            }\n            else if (move.color === 'w') {\n                // store the previous generated move_string if we have one\n                if (moveString.length) {\n                    moves.push(moveString);\n                }\n                moveString = this._moveNumber + '.';\n            }\n            moveString =\n                moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }));\n            this._makeMove(move);\n        }\n        // are there any other leftover moves?\n        if (moveString.length) {\n            moves.push(appendComment(moveString));\n        }\n        // is there a result? (there ALWAYS has to be a result according to spec; see Seven Tag Roster)\n        moves.push(this._header.Result || '*');\n        /*\n         * history should be back to what it was before we started generating PGN,\n         * so join together moves\n         */\n        if (maxWidth === 0) {\n            return result.join('') + moves.join(' ');\n        }\n        // TODO (jah): huh?\n        const strip = function () {\n            if (result.length > 0 && result[result.length - 1] === ' ') {\n                result.pop();\n                return true;\n            }\n            return false;\n        };\n        // NB: this does not preserve comment whitespace.\n        const wrapComment = function (width, move) {\n            for (const token of move.split(' ')) {\n                if (!token) {\n                    continue;\n                }\n                if (width + token.length > maxWidth) {\n                    while (strip()) {\n                        width--;\n                    }\n                    result.push(newline);\n                    width = 0;\n                }\n                result.push(token);\n                width += token.length;\n                result.push(' ');\n                width++;\n            }\n            if (strip()) {\n                width--;\n            }\n            return width;\n        };\n        // wrap the PGN output at max_width\n        let currentWidth = 0;\n        for (let i = 0; i < moves.length; i++) {\n            if (currentWidth + moves[i].length > maxWidth) {\n                if (moves[i].includes('{')) {\n                    currentWidth = wrapComment(currentWidth, moves[i]);\n                    continue;\n                }\n            }\n            // if the current move will push past max_width\n            if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n                // don't end the line with whitespace\n                if (result[result.length - 1] === ' ') {\n                    result.pop();\n                }\n                result.push(newline);\n                currentWidth = 0;\n            }\n            else if (i !== 0) {\n                result.push(' ');\n                currentWidth++;\n            }\n            result.push(moves[i]);\n            currentWidth += moves[i].length;\n        }\n        return result.join('');\n    }\n    /**\n     * @deprecated Use `setHeader` and `getHeaders` instead. This method will return null header tags (which is not what you want)\n     */\n    header(...args) {\n        for (let i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                this._header[args[i]] = args[i + 1];\n            }\n        }\n        return this._header;\n    }\n    // TODO: value validation per spec\n    setHeader(key, value) {\n        this._header[key] = value ?? exports.SEVEN_TAG_ROSTER[key] ?? null;\n        return this.getHeaders();\n    }\n    removeHeader(key) {\n        if (key in this._header) {\n            this._header[key] = exports.SEVEN_TAG_ROSTER[key] || null;\n            return true;\n        }\n        return false;\n    }\n    // return only non-null headers (omit placemarker nulls)\n    getHeaders() {\n        const nonNullHeaders = {};\n        for (const [key, value] of Object.entries(this._header)) {\n            if (value !== null) {\n                nonNullHeaders[key] = value;\n            }\n        }\n        return nonNullHeaders;\n    }\n    loadPgn(pgn, { strict = false, newlineChar = '\\r?\\n', } = {}) {\n        function mask(str) {\n            return str.replace(/\\\\/g, '\\\\');\n        }\n        function parsePgnHeader(header) {\n            const headerObj = {};\n            const headers = header.split(new RegExp(mask(newlineChar)));\n            let key = '';\n            let value = '';\n            for (let i = 0; i < headers.length; i++) {\n                const regex = /^\\s*\\[\\s*([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/;\n                key = headers[i].replace(regex, '$1');\n                value = headers[i].replace(regex, '$2');\n                if (key.trim().length > 0) {\n                    headerObj[key] = value;\n                }\n            }\n            return headerObj;\n        }\n        // strip whitespace from head/tail of PGN block\n        pgn = pgn.trim();\n        /*\n         * RegExp to split header. Takes advantage of the fact that header and movetext\n         * will always have a blank line between them (ie, two newline_char's). Handles\n         * case where movetext is empty by matching newlineChar until end of string is\n         * matched - effectively trimming from the end extra newlineChar.\n         *\n         * With default newline_char, will equal:\n         * /^(\\[((?:\\r?\\n)|.)*\\])((?:\\s*\\r?\\n){2}|(?:\\s*\\r?\\n)*$)/\n         */\n        const headerRegex = new RegExp('^(\\\\[((?:' +\n            mask(newlineChar) +\n            ')|.)*\\\\])' +\n            '((?:\\\\s*' +\n            mask(newlineChar) +\n            '){2}|(?:\\\\s*' +\n            mask(newlineChar) +\n            ')*$)');\n        // If no header given, begin with moves.\n        const headerRegexResults = headerRegex.exec(pgn);\n        const headerString = headerRegexResults\n            ? headerRegexResults.length >= 2\n                ? headerRegexResults[1]\n                : ''\n            : '';\n        // Put the board in the starting position\n        this.reset();\n        // parse PGN header\n        const headers = parsePgnHeader(headerString);\n        let fen = '';\n        for (const key in headers) {\n            // check to see user is including fen (possibly with wrong tag case)\n            if (key.toLowerCase() === 'fen') {\n                fen = headers[key];\n            }\n            this.header(key, headers[key]);\n        }\n        /*\n         * the permissive parser should attempt to load a fen tag, even if it's the\n         * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n         */\n        if (!strict) {\n            if (fen) {\n                this.load(fen, { preserveHeaders: true });\n            }\n        }\n        else {\n            /*\n             * strict parser - load the starting position indicated by [Setup '1']\n             * and [FEN position]\n             */\n            if (headers['SetUp'] === '1') {\n                if (!('FEN' in headers)) {\n                    throw new Error('Invalid PGN: FEN tag must be supplied with SetUp tag');\n                }\n                // don't clear the headers when loading\n                this.load(headers['FEN'], { preserveHeaders: true });\n            }\n        }\n        /*\n         * NB: the regexes below that delete move numbers, recursive annotations,\n         * and numeric annotation glyphs may also match text in comments. To\n         * prevent this, we transform comments by hex-encoding them in place and\n         * decoding them again after the other tokens have been deleted.\n         *\n         * While the spec states that PGN files should be ASCII encoded, we use\n         * {en,de}codeURIComponent here to support arbitrary UTF8 as a convenience\n         * for modern users\n         */\n        function toHex(s) {\n            return Array.from(s)\n                .map(function (c) {\n                /*\n                 * encodeURI doesn't transform most ASCII characters, so we handle\n                 * these ourselves\n                 */\n                return c.charCodeAt(0) < 128\n                    ? c.charCodeAt(0).toString(16)\n                    : encodeURIComponent(c).replace(/%/g, '').toLowerCase();\n            })\n                .join('');\n        }\n        function fromHex(s) {\n            return s.length == 0\n                ? ''\n                : decodeURIComponent('%' + (s.match(/.{1,2}/g) || []).join('%'));\n        }\n        const encodeComment = function (s) {\n            s = s.replace(new RegExp(mask(newlineChar), 'g'), ' ');\n            return `{${toHex(s.slice(1, s.length - 1))}}`;\n        };\n        const decodeComment = function (s) {\n            if (s.startsWith('{') && s.endsWith('}')) {\n                return fromHex(s.slice(1, s.length - 1));\n            }\n        };\n        // delete header to get the moves\n        let ms = pgn\n            .replace(headerString, '')\n            .replace(\n        // encode comments so they don't get deleted below\n        new RegExp(`({[^}]*})+?|;([^${mask(newlineChar)}]*)`, 'g'), function (_match, bracket, semicolon) {\n            return bracket !== undefined\n                ? encodeComment(bracket)\n                : ' ' + encodeComment(`{${semicolon.slice(1)}}`);\n        })\n            .replace(new RegExp(mask(newlineChar), 'g'), ' ');\n        // delete recursive annotation variations\n        const ravRegex = /(\\([^()]+\\))+?/g;\n        while (ravRegex.test(ms)) {\n            ms = ms.replace(ravRegex, '');\n        }\n        // delete move numbers\n        ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '');\n        // delete ... indicating black to move\n        ms = ms.replace(/\\.\\.\\./g, '');\n        /* delete numeric annotation glyphs */\n        ms = ms.replace(/\\$\\d+/g, '');\n        // trim and get array of moves\n        let moves = ms.trim().split(new RegExp(/\\s+/));\n        // delete empty entries\n        moves = moves.filter((move) => move !== '');\n        let result = '';\n        for (let halfMove = 0; halfMove < moves.length; halfMove++) {\n            const comment = decodeComment(moves[halfMove]);\n            if (comment !== undefined) {\n                this._comments[this.fen()] = comment;\n                continue;\n            }\n            const move = this._moveFromSan(moves[halfMove], strict);\n            // invalid move\n            if (move == null) {\n                // was the move an end of game marker\n                if (TERMINATION_MARKERS.indexOf(moves[halfMove]) > -1) {\n                    result = moves[halfMove];\n                }\n                else {\n                    throw new Error(`Invalid move in PGN: ${moves[halfMove]}`);\n                }\n            }\n            else {\n                // reset the end of game marker if making a valid move\n                result = '';\n                this._makeMove(move);\n                this._incPositionCount(this.fen());\n            }\n        }\n        /*\n         * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n         * the termination marker. Only do this when headers are present, but the\n         * result tag is missing\n         */\n        if (result &&\n            Object.keys(this._header).length &&\n            this._header['Result'] !== result) {\n            this.setHeader('Result', result);\n        }\n    }\n    /*\n     * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} strict Use the strict SAN parser. It will throw errors\n     * on overly disambiguated moves (see below):\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    _moveToSan(move, moves) {\n        let output = '';\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O';\n        }\n        else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O';\n        }\n        else {\n            if (move.piece !== exports.PAWN) {\n                const disambiguator = getDisambiguator(move, moves);\n                output += move.piece.toUpperCase() + disambiguator;\n            }\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === exports.PAWN) {\n                    output += algebraic(move.from)[0];\n                }\n                output += 'x';\n            }\n            output += algebraic(move.to);\n            if (move.promotion) {\n                output += '=' + move.promotion.toUpperCase();\n            }\n        }\n        this._makeMove(move);\n        if (this.isCheck()) {\n            if (this.isCheckmate()) {\n                output += '#';\n            }\n            else {\n                output += '+';\n            }\n        }\n        this._undoMove();\n        return output;\n    }\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    _moveFromSan(move, strict = false) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        const cleanMove = strippedSan(move);\n        let pieceType = inferPieceType(cleanMove);\n        let moves = this._moves({ legal: true, piece: pieceType });\n        // strict parser\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n                return moves[i];\n            }\n        }\n        // the strict parser failed\n        if (strict) {\n            return null;\n        }\n        let piece = undefined;\n        let matches = undefined;\n        let from = undefined;\n        let to = undefined;\n        let promotion = undefined;\n        /*\n         * The default permissive (non-strict) parser allows the user to parse\n         * non-standard chess notations. This parser is only run after the strict\n         * Standard Algebraic Notation (SAN) parser has failed.\n         *\n         * When running the permissive parser, we'll run a regex to grab the piece, the\n         * to/from square, and an optional promotion piece. This regex will\n         * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n         * f7f8q, b1c3\n         *\n         * NOTE: Some positions and moves may be ambiguous when using the permissive\n         * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n         * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n         * move). In these cases, the permissive parser will default to the most\n         * basic interpretation (which is b1c3 parsing to Nc3).\n         */\n        let overlyDisambiguated = false;\n        matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);\n        if (matches) {\n            piece = matches[1];\n            from = matches[2];\n            to = matches[3];\n            promotion = matches[4];\n            if (from.length == 1) {\n                overlyDisambiguated = true;\n            }\n        }\n        else {\n            /*\n             * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n             * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n             * there is one legal knight move to e7). In this case, the value of\n             * 'from' variable will be a rank or file, not a square.\n             */\n            matches = cleanMove.match(/([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/);\n            if (matches) {\n                piece = matches[1];\n                from = matches[2];\n                to = matches[3];\n                promotion = matches[4];\n                if (from.length == 1) {\n                    overlyDisambiguated = true;\n                }\n            }\n        }\n        pieceType = inferPieceType(cleanMove);\n        moves = this._moves({\n            legal: true,\n            piece: piece ? piece : pieceType,\n        });\n        if (!to) {\n            return null;\n        }\n        for (let i = 0, len = moves.length; i < len; i++) {\n            if (!from) {\n                // if there is no from square, it could be just 'x' missing from a capture\n                if (cleanMove ===\n                    strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')) {\n                    return moves[i];\n                }\n                // hand-compare move properties with the results from our permissive regex\n            }\n            else if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                Ox88[from] == moves[i].from &&\n                Ox88[to] == moves[i].to &&\n                (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                return moves[i];\n            }\n            else if (overlyDisambiguated) {\n                /*\n                 * SPECIAL CASE: we parsed a move string that may have an unneeded\n                 * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n                 */\n                const square = algebraic(moves[i].from);\n                if ((!piece || piece.toLowerCase() == moves[i].piece) &&\n                    Ox88[to] == moves[i].to &&\n                    (from == square[0] || from == square[1]) &&\n                    (!promotion || promotion.toLowerCase() == moves[i].promotion)) {\n                    return moves[i];\n                }\n            }\n        }\n        return null;\n    }\n    ascii() {\n        let s = '   +------------------------+\\n';\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            // display the rank\n            if (file(i) === 0) {\n                s += ' ' + '87654321'[rank(i)] + ' |';\n            }\n            if (this._board[i]) {\n                const piece = this._board[i].type;\n                const color = this._board[i].color;\n                const symbol = color === exports.WHITE ? piece.toUpperCase() : piece.toLowerCase();\n                s += ' ' + symbol + ' ';\n            }\n            else {\n                s += ' . ';\n            }\n            if ((i + 1) & 0x88) {\n                s += '|\\n';\n                i += 8;\n            }\n        }\n        s += '   +------------------------+\\n';\n        s += '     a  b  c  d  e  f  g  h';\n        return s;\n    }\n    perft(depth) {\n        const moves = this._moves({ legal: false });\n        let nodes = 0;\n        const color = this._turn;\n        for (let i = 0, len = moves.length; i < len; i++) {\n            this._makeMove(moves[i]);\n            if (!this._isKingAttacked(color)) {\n                if (depth - 1 > 0) {\n                    nodes += this.perft(depth - 1);\n                }\n                else {\n                    nodes++;\n                }\n            }\n            this._undoMove();\n        }\n        return nodes;\n    }\n    turn() {\n        return this._turn;\n    }\n    board() {\n        const output = [];\n        let row = [];\n        for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n            if (this._board[i] == null) {\n                row.push(null);\n            }\n            else {\n                row.push({\n                    square: algebraic(i),\n                    type: this._board[i].type,\n                    color: this._board[i].color,\n                });\n            }\n            if ((i + 1) & 0x88) {\n                output.push(row);\n                row = [];\n                i += 8;\n            }\n        }\n        return output;\n    }\n    squareColor(square) {\n        if (square in Ox88) {\n            const sq = Ox88[square];\n            return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark';\n        }\n        return null;\n    }\n    history({ verbose = false } = {}) {\n        const reversedHistory = [];\n        const moveHistory = [];\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            if (verbose) {\n                moveHistory.push(new Move(this, move));\n            }\n            else {\n                moveHistory.push(this._moveToSan(move, this._moves()));\n            }\n            this._makeMove(move);\n        }\n        return moveHistory;\n    }\n    /*\n     * Keeps track of position occurrence counts for the purpose of repetition\n     * checking. All three methods (`_inc`, `_dec`, and `_get`) trim the\n     * irrelevent information from the fen, initialising new positions, and\n     * removing old positions from the record if their counts are reduced to 0.\n     */\n    _getPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        return this._positionCount[trimmedFen] || 0;\n    }\n    _incPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === undefined) {\n            this._positionCount[trimmedFen] = 0;\n        }\n        this._positionCount[trimmedFen] += 1;\n    }\n    _decPositionCount(fen) {\n        const trimmedFen = trimFen(fen);\n        if (this._positionCount[trimmedFen] === 1) {\n            delete this._positionCount[trimmedFen];\n        }\n        else {\n            this._positionCount[trimmedFen] -= 1;\n        }\n    }\n    _pruneComments() {\n        const reversedHistory = [];\n        const currentComments = {};\n        const copyComment = (fen) => {\n            if (fen in this._comments) {\n                currentComments[fen] = this._comments[fen];\n            }\n        };\n        while (this._history.length > 0) {\n            reversedHistory.push(this._undoMove());\n        }\n        copyComment(this.fen());\n        while (true) {\n            const move = reversedHistory.pop();\n            if (!move) {\n                break;\n            }\n            this._makeMove(move);\n            copyComment(this.fen());\n        }\n        this._comments = currentComments;\n    }\n    getComment() {\n        return this._comments[this.fen()];\n    }\n    setComment(comment) {\n        this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']');\n    }\n    /**\n     * @deprecated Renamed to `removeComment` for consistency\n     */\n    deleteComment() {\n        return this.removeComment();\n    }\n    removeComment() {\n        const comment = this._comments[this.fen()];\n        delete this._comments[this.fen()];\n        return comment;\n    }\n    getComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            return { fen: fen, comment: this._comments[fen] };\n        });\n    }\n    /**\n     * @deprecated Renamed to `removeComments` for consistency\n     */\n    deleteComments() {\n        return this.removeComments();\n    }\n    removeComments() {\n        this._pruneComments();\n        return Object.keys(this._comments).map((fen) => {\n            const comment = this._comments[fen];\n            delete this._comments[fen];\n            return { fen: fen, comment: comment };\n        });\n    }\n    setCastlingRights(color, rights) {\n        for (const side of [exports.KING, exports.QUEEN]) {\n            if (rights[side] !== undefined) {\n                if (rights[side]) {\n                    this._castling[color] |= SIDES[side];\n                }\n                else {\n                    this._castling[color] &= ~SIDES[side];\n                }\n            }\n        }\n        this._updateCastlingRights();\n        const result = this.getCastlingRights(color);\n        return ((rights[exports.KING] === undefined || rights[exports.KING] === result[exports.KING]) &&\n            (rights[exports.QUEEN] === undefined || rights[exports.QUEEN] === result[exports.QUEEN]));\n    }\n    getCastlingRights(color) {\n        return {\n            [exports.KING]: (this._castling[color] & SIDES[exports.KING]) !== 0,\n            [exports.QUEEN]: (this._castling[color] & SIDES[exports.QUEEN]) !== 0,\n        };\n    }\n    moveNumber() {\n        return this._moveNumber;\n    }\n}\nexports.Chess = Chess;\n//# sourceMappingURL=chess.js.map"],"names":["Object","defineProperty","exports","value","Chess","validateFen","SEVEN_TAG_ROSTER","SQUARES","Move","DEFAULT_POSITION","KING","QUEEN","ROOK","BISHOP","KNIGHT","PAWN","BLACK","WHITE","color","from","to","piece","captured","promotion","flags","san","lan","before","after","constructor","chess","internal","fromAlgebraic","algebraic","toAlgebraic","this","legal","fen","flag","BITS","FLAGS","isCapture","indexOf","isPromotion","isEnPassant","isKingsideCastle","isQueensideCastle","isBigPawn","EMPTY","NORMAL","CAPTURE","BIG_PAWN","EP_CAPTURE","PROMOTION","KSIDE_CASTLE","QSIDE_CASTLE","Event","Site","Date","Round","White","Black","Result","SUPLEMENTAL_TAGS","WhiteTitle","BlackTitle","WhiteElo","BlackElo","WhiteUSCF","BlackUSCF","WhiteNA","BlackNA","WhiteType","BlackType","EventDate","EventSponsor","Section","Stage","Board","Opening","Variation","SubVariation","ECO","NIC","Time","UTCTime","UTCDate","TimeControl","SetUp","FEN","Termination","Annotator","Mode","PlyCount","HEADER_TEMPLATE","Ox88","a8","b8","c8","d8","e8","f8","g8","h8","a7","b7","c7","d7","e7","f7","g7","h7","a6","b6","c6","d6","e6","f6","g6","h6","a5","b5","c5","d5","e5","f5","g5","h5","a4","b4","c4","d4","e4","f4","g4","h4","a3","b3","c3","d3","e3","f3","g3","h3","a2","b2","c2","d2","e2","f2","g2","h2","a1","b1","c1","d1","e1","f1","g1","h1","PAWN_OFFSETS","b","w","PIECE_OFFSETS","n","r","q","k","ATTACKS","RAYS","PIECE_MASKS","p","SYMBOLS","PROMOTIONS","RANK_1","RANK_2","RANK_7","RANK_8","SIDES","ROOKS","square","SECOND_RANK","TERMINATION_MARKERS","rank","file","isDigit","c","f","substring","swapColor","tokens","split","length","ok","error","moveNumber","parseInt","isNaN","halfMoves","test","rows","let","i","sumFields","previousWasNumber","kings","regex","match","Array","some","char","toUpperCase","getDisambiguator","move","moves","ambiguities","sameRank","sameFile","len","ambigFrom","ambigTo","ambigPiece","charAt","addMove","undefined","push","inferPieceType","pieceType","matches","toLowerCase","strippedSan","replace","trimFen","slice","join","_board","_turn","_header","_kings","_epSquare","_halfMoves","_moveNumber","_history","_comments","_castling","_positionCount","skipValidation","load","clear","preserveHeaders","adjustments","concat","Error","position","_put","type","_updateSetup","_incPositionCount","empty","castling","epSquare","bigPawnSquare","squares","_makeMove","isLegal","_isKingAttacked","_undoMove","reset","get","findPiece","put","_updateCastlingRights","_updateEnPassantSquare","sq","currentPieceOnSquare","remove","whiteKingInPlace","blackKingInPlace","startSquare","currentSquare","attackers","canCapture","_attacked","verbose","difference","index","offset","j","blocked","attackedBy","isAttacked","isCheck","inCheck","isCheckmate","_moves","isStalemate","isInsufficientMaterial","pieces","bishops","numPieces","squareColor","sum","isThreefoldRepetition","_getPositionCount","isDrawByFiftyMoves","isDraw","isGameOver","map","_moveToSan","forSquare","forPiece","us","them","firstSquare","lastSquare","singleSquare","castlingFrom","castlingTo","legalMoves","strict","moveObj","_moveFromSan","JSON","stringify","prettyMove","_push","turn","undo","_decPositionCount","old","pop","pgn","newline","maxWidth","result","headerExists","headerTag","appendComment","comment","delimiter","moveString","reversedHistory","prefix","strip","wrapComment","width","token","currentWidth","includes","header","args","setHeader","key","getHeaders","removeHeader","nonNullHeaders","entries","loadPgn","newlineChar","mask","str","parsePgnHeader","headerObj","headers","RegExp","trim","headerRegex","headerRegexResults","exec","headerString","toHex","s","charCodeAt","toString","encodeURIComponent","fromHex","decodeURIComponent","encodeComment","decodeComment","startsWith","endsWith","ms","_match","bracket","semicolon","ravRegex","filter","halfMove","keys","output","disambiguator","cleanMove","overlyDisambiguated","ascii","symbol","perft","depth","nodes","board","row","history","moveHistory","trimmedFen","_pruneComments","currentComments","copyComment","getComment","setComment","deleteComment","removeComment","getComments","deleteComments","removeComments","setCastlingRights","rights","side","getCastlingRights"],"mappings":"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"}